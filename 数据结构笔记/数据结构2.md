第五章 树

## 5.1 树的基本概念

![image-20220607170908675](数据结构2.assets/image-20220607170908675.png)

![image-20220607170957770](数据结构2.assets/image-20220607170957770.png)

树也有前驱和后继，右图中，C，B，D都是A的后继，反过来，A是C，B，D的前驱





空树：结点数为0的树



非空树的特点：

1. 有且仅有一个**根节点**，根节点没有前驱
2. 没有后继的结点称为**叶子结点**(终端结点)
3. 有后继的结点称为**分支结点**(非终端结点)
4. 每个结点都可以有0个或多个前驱
5. 除了根节点外，任何一个结点都有且仅有一个前驱





一个结点有两个前驱就不是树了

<img src="数据结构2.assets/image-20220607171629398.png" alt="image-20220607171629398" style="zoom:50%;" />

这两张图是 图 ，网了。





树是*n*（*n*≥0）个结点的有限集合，*n* = 0时，称为空树，这是一种特殊情况。

在任意一棵非空树中应满足：

1）有且仅有一个特定的称为**根结点**。

2）当*n* > 1时，其余结点可分为 *m*（*m* > 0）个**互不相交**(每个结点只有一个前驱)的有限集合*T*<sub>1</sub>, *T*<sub>2</sub>,…, *T<sub>m</sub>*，其中每个集合本身又是一棵树，并且称为根结点的子树。



什么叫 "其余结点可分为m个互不相交的子树"

A结点有3棵子树

<img src="数据结构2.assets/image-20220607172100027.png" alt="image-20220607172100027" style="zoom:67%;" />

B为根节点，B结点有2棵子树

![image-20220607172209852](数据结构2.assets/image-20220607172209852.png)

F为根结点，其没有子树，或者说，子树是空树

![image-20220607180706437](数据结构2.assets/image-20220607180706437.png)



<font color = red size=4>树是一种递归定义的数据结构</font>



树型结构的典型例子

电脑里的文件

![image-20220607180849972](数据结构2.assets/image-20220607180849972.png)

思维导图都是数据结构

![image-20220607180911293](数据结构2.assets/image-20220607180911293.png)





## 5.2 树的基本术语

### 结点之间的关系描述

<img src="数据结构2.assets/image-20220607181647936.png" alt="image-20220607181647936" style="zoom: 67%;" />



1. **祖先结点**：从当前结点不断找其前驱，一直找到根节点为止，找到的所有前驱都是当前结点的祖先结点

   对于 图中的 **你**这个结点 来说，   父亲 爷爷是祖先结点

   对于 图中的 **G**这个结点 来说，   二叔 爷爷是祖先结点

2. **子孙结点**: 从当前结点不断找后继，一直找到叶子结点位置，找到的所有后继都是当先结点的子孙结点

   对于 图中的 **你**这个结点 来说，K和L 是后继结点

   对于 图中的 **爷爷**这个结点 来说，图上所有的结点都是子孙结点

3. **双亲结点**(父结点)：当前结点的直接前驱，是双亲结点

   对于 图中的 **你**这个结点 来说，**父亲**是双亲结点

   对于 图中的 **爷爷**这个结点 来说，没有双亲结点

4. **孩子结点**：当前结点的直接后继，是孩子结点

   图中的 **你**这个结点 来说， K 和 L 是 孩子结点

   图中的 **爷爷**这个结点 来说，父亲，二叔，三叔是孩子结点

   

5. **兄弟结点**：拥有同一个直接前驱的结点，彼此之间是兄弟结点的关系

   图中    你 和 F ，  H 和 I ，I 和 J 彼此之间都是兄弟结点

6. **堂兄弟结点**：拥有的直接前驱不是同一个，但是拥有的直接前驱是**处于同一层次**，彼此之间是堂兄弟结点

   图中   GH GI GJ  彼此之间是堂兄弟结点

7. **两个结点之间的路径**：从祖先结点找到子孙结点，方向不能反过来，是单向的

   爷爷结点 到 你结点  的 唯一路径是     爷爷-> 父亲 -> 你  而不能是    你->父亲->爷爷

8. **边**：两个结点间的连线称为边

9. **路径长度**：路径经过了几条边

   爷爷-> 父亲 -> 你  边数是 3

   





### 结点的属性和树的属性描述

结点的层次(深度)

<img src="数据结构2.assets/image-20220607183206867.png" alt="image-20220607183206867" style="zoom: 67%;" />



1. **结点的层次(深度**)：从上(根节点)往下(叶子结点)数，根节点所在层数是第 1 层，看当前结点的深度

   A的深度是 1   B C D 是 2     E F G H I J 是 3   K L M 是 4

2. **结点的高度**：从下往上数，叶子结点所在层数是第 1 层，看当前结点的高度

   K L M 的高度是 1    E F G H I J 高度是 2     A的高度是4

3. **树的高度**(**深度**):根节点到叶子结点，最大多少层

   上图中，数的高度 是 4 层

4. **结点的度**：一个结点有几个孩子(分支)就有 几个度，**叶子结点度为0，非叶子节点度>0**

   A有 3 个 度    H 只有一个度，    G没有度

5. **树的度**：各结点的度中，最大的那个度作为该数的度

   该数的度 为 3

   

#### 有序树和无顺树

**有序树**：逻辑上看，树中结点的各子树从左至右是**有次序**的，不能互换

比如：家谱树

<img src="数据结构2.assets/image-20220607181647936.png" alt="image-20220607181647936" style="zoom: 67%;" />

家谱的顺序是按出生顺序决定的，不能交换



**无序树**：逻辑上看，树中结点的各子树从左至右是**无次序**的，可以互换

![image-20220607180911293](数据结构2.assets/image-20220607180911293.png)

只反映各个省有哪些市，无所谓顺序



具体看这个树存的是什么，是否需要用结点的左右位置反应某些逻辑关系







#### 树和森林

**森林**：森林是 m(m >= 0) 棵互不相交的树的集合 , m = 0时，此时是空森林

<img src="数据结构2.assets/image-20220607185030484.png" alt="image-20220607185030484" style="zoom: 67%;" />

 

<img src="数据结构2.assets/image-20220607185038053.png" alt="image-20220607185038053" style="zoom: 67%;" />



## 5.3 树的性质

![image-20220607204325415](数据结构2.assets/image-20220607204325415.png)

性质一：对于一棵树来说，   **该树的所有结点数 = 该树所有的结点的度数 + 1**   

+1 是因为根节点没有前驱





性质二：**度数为 m 的数** 和  **m叉树**的区别



度数为 m 的树满足：

1. 该树内所有结点的度都小于等于 m
2. 该树内的结点中，至少有一个结点的度数是m(有 m 个孩子)
3. 一定是非空树，至少有 m + 1 个结点

<img src="数据结构2.assets/image-20220607202924198.png" alt="image-20220607202924198" style="zoom:50%;" />

m 叉树满足：

1. 该树内所有结点的度都小于等于 m
2. 允许所有的结点的度都小于m
3. 可以是空树，此时即为m叉空树

![image-20220607202935362](数据结构2.assets/image-20220607202935362.png)





性质三

度为 m 的树第 i 层至多有 **m<sup>i-1</sup>**个结点 i>=1

m 叉树第 i 层至多有 m<sup>i-1</sup>个结点 i>=1

因为这两个都有 **该树内所有结点的度都小于等于 m** 这条性质

![image-20220607203322775](数据结构2.assets/image-20220607203322775.png)





性质四

在性质三的基础上得到的，用等比数列求和公式

![image-20220607203734727](数据结构2.assets/image-20220607203734727.png)



性质五

高度为h的**m叉树**至少有 h 个结点。(此时每个结点只有一个前驱，一个后继)

![image-20220607204100027](数据结构2.assets/image-20220607204100027.png)



**高度为h、度为m的树**至少有 h+m-1 个结点(此时只有一个结点的度为m，叶子结点度为0，其余结点度为1)

![image-20220607204306259](数据结构2.assets/image-20220607204306259.png)



性质六

常见考点6：具有n个结点的m叉树的最小高度为 **log<sub>m</sub>(n(m - 1) + 1)<sub>向上取整</sub>**

高度最小就是要这棵树尽可能宽

![image-20220607204254179](数据结构2.assets/image-20220607204254179.png)







## 5.4 二叉树

![image-20220608183219317](数据结构2.assets/image-20220608183219317.png)



### 5.4.1 二叉树的基本概念

二叉树是*n*（*n*≥0）个结点的有限集合：

① 二叉树可以是空二叉树，即*n* = 0。 

② 非空二叉树看成由 **一个根结点** 和 **两个互不相交的被称为根的左子树和右子树** 组成。**左子树和右子树**

**又分别是一棵二叉树。**(二叉树是一种递归定义的数据结构)

特点：①每个结点**至多只有两棵子树** ②左右子树不能颠倒（**二叉树是有序树**）

二叉树和度数为2的树不同





![image-20220608175646371](数据结构2.assets/image-20220608175646371.png)

非空树总是可以看成一个结点和两个子树，其子树可以是一个空树



![image-20220608175917797](数据结构2.assets/image-20220608175917797.png)



二叉树的5种状态

![image-20220608180018476](数据结构2.assets/image-20220608180018476.png)



### 5.4.2 几种特殊的二叉树

**满二叉树**(完全填满，没有空间)

一棵高度为 *h*，且含有 2<sup>*h*</sup> - 1个结点的二叉树

除了叶子结点外的所有结点(及所有分支结点)都有两个度

![image-20220608180047574](数据结构2.assets/image-20220608180047574.png)



特点：

①只有最后一层有叶子结点

②不存在度为 1 的结点，只有度为0的结点(叶子结点)，和度为1的结点(分支结点)

③按**从上往下，从左往右**的顺序从 1 开始编号，结点 i 的左孩子为 2i，右孩子为 2i+1；结点 i 的父节点为 (i/2)<sub>向下取整</sub> （如果有父结点的话）

**从上往下，从左往右**

<img src="数据结构2.assets/image-20220608180602692.png" alt="image-20220608180602692" style="zoom:50%;" />



 

**完全二叉树**

完全二叉树。

当且仅当其每个结点都与高度为*h*的满二叉树中编号(从上往下，从左到右)为1～*n*的结点一一对应时，称为

完全二叉树

![image-20220608181202228](数据结构2.assets/image-20220608181202228.png)

特点：

①只有最后两层可能有叶子结点

②最多只有一个度为1的结点

③按**从上往下，从左往右**的顺序从 1 开始编号，结点 i 的左孩子为 2i，右孩子为 2i+1；结点 i 的父节点为 ?/2 （如果有的话）

④ i≤ (n/2)<sub>向下取整</sub> 为分支结点， i> (n/2)<sub>向下取整</sub> 为叶子结点



满二叉一定是完全二叉，完全二叉不一定是满二叉树





这个图不是完全二叉树

![image-20220608181557967](数据结构2.assets/image-20220608181557967.png)

满二叉

![image-20220608181647765](数据结构2.assets/image-20220608181647765.png)

完全二叉

![image-20220608181708170](数据结构2.assets/image-20220608181708170.png)

不是完全二叉

![image-20220608181754100](数据结构2.assets/image-20220608181754100.png)

由满二叉得到完全二叉树，必须从满二叉的右下角开始，**向左向上依次擦去结点，不能跳着擦去**，一定要依次擦去，一层全部擦完了才能到上面一层

<img src="数据结构2.assets/image-20220608182207293.png" alt="image-20220608182207293" style="zoom:67%;" />





**二叉排序树**

一棵空二叉树是二叉排序树，非空二叉树具有如下性质也是二叉排序树：

1. 左子树上所有结点的关键字均小于根结点的关键字；

2. 右子树上所有结点的关键字均大于根结点的关键字。

3. 左子树和右子树又各是一棵二叉排序树。（递归定义)



二叉排序树可用于元素的快速排序、搜索

<img src="数据结构2.assets/image-20220608182547263.png" alt="image-20220608182547263" style="zoom:67%;" />





<img src="数据结构2.assets/image-20220608182611715.png" alt="image-20220608182611715" style="zoom: 67%;" />

<img src="数据结构2.assets/image-20220608182648278.png" alt="image-20220608182648278" style="zoom: 67%;" />

根据当前这个树的根节点，如果比根节点大就往右找，比根结点小就往左找

到达当前树的子树，也是这样来找，(递归)





**平衡二叉树**

树上**任一结点的左子树和右子树的深度之差不超过1**

平衡二叉树有**更高的搜索效率**，路径长度不会太离谱



平衡二叉树比较胖

该树是二叉平衡排序树，找70，50 66 70 只要找3次

![image-20220608182903419](数据结构2.assets/image-20220608182903419.png)

非平衡二叉树比较瘦



该树是二叉排序树，但不平衡，甚至长短脚，找70 ，26 30 50 60 66 68 70 需要找 7 次

![image-20220608182938835](数据结构2.assets/image-20220608182938835.png)





### 5.4.3 二叉树的性质



![image-20220608190409290](数据结构2.assets/image-20220608190409290.png)

**性质一：**

设非空二叉树中，度为0、1和2的结点个数分别为*n*0、*n*1和*n*2，*则* *n*0 = *n*2 + 1（叶子结点比二分支结点多一个）

假设树中结点总数为 n，则

① n = *n*0 + *n*1 + *n*2 

② n = *n*1 + 2*n*2 +1  (树的结点数=总度数( *n*1 + 2*n*2)+1)

② - ① 得到

***n*0 = *n*2 + 1**（对所有二叉树都有)





![image-20220608185114963](数据结构2.assets/image-20220608185114963.png)

性质二：

**二叉树第 i 层至多有 2<sup>i</sup>-1 个结点**（i≥1）

……

第 1 层：m0 

第 2 层：m1 

第 3 层：m2 

第 4 层：m3 

m叉树第 i 层至多有 m<sup>i-1</sup> 个结点（i≥1）这是树的性质  m =2带进去就是二叉树的性质

![image-20220608185340547](数据结构2.assets/image-20220608185340547.png)





性质三：

![image-20220608185421924](数据结构2.assets/image-20220608185421924.png)

m = 2 带进去





性质四：

具有*n*个（*n* > 0）结点的**完全二叉树**的高度h为 (log<sub>2</sub>(*n* + 1))<sub>向下取整</sub>   或  (log<sub>2</sub>*n*)<sub>向上取整</sub>+1



证明过程

![image-20220608185620908](数据结构2.assets/image-20220608185620908.png)



![image-20220608185905248](数据结构2.assets/image-20220608185905248.png)

附加结论：

第 *i* *个结点*所在层次为    (log2(*n* + 1))<sub>向上取整</sub>   或     (log(2*n*)+ 1)<sub>向下取整</sub>





**性质五：**

对于**完全二叉树**，可以由树的结点数 n 推出度为0、1和2的结点个数为*n*0、*n*1和*n*2 

过程：

完全二叉树**最多只有一个度为1的结点**  *n*1=0或1

*n*0 = *n*2 + 1(性质一) 推出  *n*0 + *n*2 一定是奇数

n0+n1+n2 = n

若完全二叉树有 2k 个（偶数）个结点，则

必有 *n*1 = 1， *n*0 = k， *n*2 = k-1

若完全二叉树有2k-1个（奇数）个结点，则

必有 *n*1=0， *n*0 = k， *n*2 = k-1





### 5.4.4 二叉树的存储结构

![image-20220609131009072](数据结构2.assets/image-20220609131009072.png)

####  顺序存储结构

##### <u>完全二叉树</u>的顺序存储结构

1. 二叉树**一个结点的定义**方式：

   ```
   struct TreeNode{
   	ElemType value;  // 该结点存储的数据元素是什么
   	bool isEmpty ;	 // 用于判断该结点是否为空
   }
   ```

2. 定义一个数组，长度为 MaxSize，数据的元素类型为 TreeNode

   ```
   TreeNode t[MaxSize]
   ```

3. 对这个数组进行初始化，一开始是空树，那么每个结点都是空结点**，每个结点的 isEmpty 都是 true**

   ```
   for(int i = 0 ;i<MaxSize;i++){
   	t[i].isEmpty = true
   }
   ```

4. 根据一个完全二叉树

   ![image-20220609155832708](数据结构2.assets/image-20220609155832708.png)

   按照**从上至下，从左至右**的顺序依次存储完全二叉树中的各个结点，要求**结点的标号和数组的索引一一对应**

   

   得到这样一个数组      数组的第一个元素索引为0，所以直接空出来

   ![image-20220609155936230](数据结构2.assets/image-20220609155936230.png)

   

几个重要的基本操作

已知完全二叉树中的一个结点的编号为 i ,(完全二叉树按照标准的方式编号)

TreeNode t[MaxSize]  数组为 t

1. 怎么取到 i ？    答： **t[i]** 一次找到
2. 找到 i 的左孩子   答： **t[2i]**   由完全二叉树的性质
3. 找到 i 的右孩子   答：**t[2i+1]**  由完全二叉树的性质 
4. 找到 i 的 父结点    答:    t[**（i/2）<sub>向下取整</sub>]**    由完全二叉树的性质 
5. 找到 i 所在的层次   答：  (log<sub>2</sub>(n+1))<sub>向上取整</sub>    或者    (log<sub>2</sub>n)<sub>向下取整</sub>+1



假设完全二叉树中共有n个结点，已知 一结点编号为 i

则  如何判断 i 是否有左孩子：  如果  2*i 小于等于 n 就有左孩子

则  如何判断 i 是否有右孩子：  如果  2*i+1 大于等于 n 就有右孩子

则  如何判断 i 是否 是 叶子 或者 分支结点       i>(n/2)<sub>向下取整</sub>就是叶子结点    i<(n/2)<sub>向下取整</sub>就是分支结点









##### 非完全二叉树的顺序存储结构

二叉树的顺序存储中，一定要把**二叉树的结点编号与完全二叉树对应起来**



这是 完全二叉

<img src="数据结构2.assets/image-20220609161243530.png" alt="image-20220609161243530" style="zoom:67%;" />



这是普通二叉(透明部分是没有的)，**但是编号方式和完全二叉树一摸一样**

<img src="数据结构2.assets/image-20220609161310018.png" alt="image-20220609161310018" style="zoom: 67%;" />

然后 还是  结点的编号和索引的编号要保持一致

![image-20220609161542509](数据结构2.assets/image-20220609161542509.png)

没有的地方就置空



已知普通二叉树中的一个结点的编号为 i ,(完全二叉树按照标准的方式编号)

TreeNode t[MaxSize]  数组为 t

1. 怎么取到 i ？    答： **t[i]** 一次找到
2. 找到 i 的左孩子   答： **t[2i]**   由完全二叉树的性质
3. 找到 i 的右孩子   答：**t[2i+1]**  由完全二叉树的性质 
4. 找到 i 的 父结点    答:    t[**（i/2）<sub>向下取整</sub>]**    由完全二叉树的性质 
5. 找到 i 所在的层次   答：  (log<sub>2</sub>(n+1))<sub>向上取整</sub>    或者    (log<sub>2</sub>n)<sub>向下取整</sub>+1

1，2，3，4，5结论，如果那个位置不为空才能找到，如果为空就找不到了













假设普通二叉树中共有n个结点，已知 一结点编号为 i

则  如何判断 i 是否有左孩子：  如果  **2*i 小于等于 n** 并且 **isEmpty为false**  就有左孩子

则  如何判断 i 是否有右孩子：  如果  **2*i+1 大于等于 n**  并且  **isEmpty为false**     就有右孩子

则  如何判断 i 是否 是 叶子 或者 分支结点 :   普通二叉树无法判断





顺序存储普通二叉树非常浪费内存

最坏情况：高度为 h 且只有 h 个结点的单支树（所有结点只有右孩子），也至少需要 2<sup>h</sup>-1 个存储单元

结论：**二叉树的顺序存储结构，只适合存储完全二叉树**

<img src="数据结构2.assets/image-20220609162411804.png" alt="image-20220609162411804" style="zoom:50%;" />

![image-20220609162355902](数据结构2.assets/image-20220609162402629.png)





#### 链式存储结构

1. 链式存储结构，二叉树的结点

   ```
   typedef struct BiTNode{
   	ElemType data;     // 数据域
   	struct BiTNode * lchild , * rchild // 左、右孩子结点
   } BiTNode,*BiTree
   BiTNode代表树结点  , BiTree代表指向树结点的指针
   ```

   ![image-20220609162932895](数据结构2.assets/image-20220609162932895.png)

   

2. 假设 ElemType 就是一个 int 类型的数据

   ```
   struct ElemType{
   	int value;
   }
   ```

   创建一颗二叉树

   ```
   BiTree root = NULL // 首先创建一棵空二叉树   root 指向根节点
   
   //插入根结点
   root = (BiTree)malloc(sizeof(BiTNode))
   root->data={1}//存储数据
   root -> lchild = NULL //还没有左子树，设置为Null
   ROOT -> rchild = NULL //还没有右子树，设置为Null
   
   
   
   // 设置根节点的左子树
   
   BiTNode * p = (BiTNode*)malloc(sizeof(BiTNode));
   p -> data = {2}
   p-> lchild = NULL
   P-> rchild = NULL
   
   
   root - > lchild = p  设置该新创建的结点为根结点的左子树 
   
   ```

   <img src="数据结构2.assets/image-20220609210244556.png" alt="image-20220609210244556" style="zoom:67%;" />





想要找到当前结点的两个子结点很简单

想要找到当前结点的父结点，必须从根节点开始遍历，



也可以创建一种三叉链表，即 还有一个直线父节点的指针

```
typedef struct BiTNode{
	ElemType data;     // 数据域
	struct BiTNode * lchild , * rchild // 左、右孩子结点
	struct BiTNode * parent  // 指向父结点的指针
} BiTNode,*BiTree
BiTNode代表树结点  , BiTree代表指向树结点的指针
```





### 5.4.5 二叉树的遍历

遍历：按照某种次序把所有的结点都访问一边



![image-20220611162942372](数据结构2.assets/image-20220611162942372.png)

#### 先序中序后序遍历

先序遍历，中序遍历，后序遍历，先 中 后 都是指的根结点



![image-20220611162956195](数据结构2.assets/image-20220611162956195.png)





在 先\中\后序遍历时，**如果访问到其左右子树发现不是空树时，那么立刻停止当前树的结点访问并且进入到<u>子树的结点访问</u>中去。**



分支结点逐层展开法，非常好用

如果 其子树为非空，那就将其作为一个整体带入

![image-20220611163739060](数据结构2.assets/image-20220611163739060.png)





例子

![image-20220611163752292](数据结构2.assets/image-20220611163752292.png)





##### 先\中\后序遍历代码



<img src="数据结构2.assets/image-20220611171518640.png" alt="image-20220611171518640" style="zoom:67%;" />





先序遍历（PreOrder）的操作过程如下：

1. 若二叉树为空，则什么也不做

2. 若二叉树非空

   (1) 访问根节点

   (2) 先序遍历左子树

   (3) 先序遍历右子树



```
typedef struct BiTNode{
	ElemType data;     // 数据域
	struct BiTNode * lchild , * rchild // 左、右孩子结点
	struct BiTNode * parent  // 指向父结点的指针
} BiTNode,*BiTree
BiTNode代表树结点  , BiTree代表指向树结点的指针

void PreOrder(BiTree T){
	if(T!=NULL){
		visit(T);//访问根节点的操作  可以printf等等
		PreOrder(T->lchild);
		PreOrder(T->rchild);
	}
}
```











中序遍历（InOrder）的操作过程如下：

1. 若二叉树为空，则什么也不做

2. 若二叉树非空

   (1) 中序遍历左子树

   (2) 访问根节点

   (3) 中序遍历右子树





```
typedef struct BiTNode{
	ElemType data;     // 数据域
	struct BiTNode * lchild , * rchild // 左、右孩子结点
	struct BiTNode * parent  // 指向父结点的指针
} BiTNode,*BiTree
BiTNode代表树结点  , BiTree代表指向树结点的指针

void InOrder(BiTree T){
	if(T!=NULL){
		InOrder(T->lchild);
		visit(T);
		InOrder(T->rchild);
	}
}
```







后序遍历（AfterOrder）的操作过程如下：

1. 若二叉树为空，则什么也不做

2. 若二叉树非空

   (1) 后序遍历左子树

   (2) 后序遍历右子树

   (3) 访问根节点

```
typedef struct BiTNode{
	ElemType data;     // 数据域
	struct BiTNode * lchild , * rchild // 左、右孩子结点
	struct BiTNode * parent  // 指向父结点的指针
} BiTNode,*BiTree
BiTNode代表树结点  , BiTree代表指向树结点的指针

void AfterOrder(BiTree T){
	if(T!=NULL){
		AfterOrder(T->lchild);
		AfterOrder(T->rchild);
		visit(T);
	}
}
```







<img src="数据结构2.assets/image-20220611171817469.png" alt="image-20220611171817469" style="zoom:67%;" />

<font color=red size=4>红色箭头表示第一次路过该结点</font>

<font color=green size=4>绿色箭头表示第二次路过该结点</font>

<font color=blue size=4>蓝色箭头表示第二次路过该结点</font>



脑补出空结点，从根节点出发，画一条路；

如果左边还有没走，优先往左边走到路的尽头(空结点)就往回走

如果左边没有路了，就往右走

如果左、右都没路了，就往上走



先序遍历-第一次路过时访问结点

中序遍历-第二次路过时访问结点

后序遍历-第三次路过时访问结点







#### 二叉树层次遍历



![image-20221012144250997](数据结构2.assets/image-20221012144250997.png)



![image-20221012144425330](数据结构2.assets/image-20221012144425330.png)



#### **由遍历序列构造二叉树**

![image-20221012144905898](数据结构2.assets/image-20221012144905898.png)

已知一个前序遍历的结果，能画出多种二叉树

已知一个中序遍历的结果，也能画出多种二叉树

已知一个后序遍历的结果，能画出多种二叉树



![image-20221012145040497](数据结构2.assets/image-20221012145040497.png)



<font color=blue size=5>已知前序遍历和中序遍历</font>

前序遍历：根结点是第一个

中序遍历：根结点是中间的那个

![image-20221012145124694](数据结构2.assets/image-20221012145124694.png)

例1：

![image-20221012145319027](数据结构2.assets/image-20221012145319027.png)



例2：

![](数据结构2.assets/image-20221012150046543.png)







![image-20221012150117177](数据结构2.assets/image-20221012150117177.png)





<font color=blue size=5>已知后序遍历和中序遍历</font>

![image-20221012150210436](数据结构2.assets/image-20221012150210436.png)



<font color=blue size=5>已知层次遍历和中序遍历</font>

![image-20221012151125408](数据结构2.assets/image-20221012151125408.png)

![image-20221012150337687](数据结构2.assets/image-20221012151129699.png)



##### 总结

![image-20221012151204167](数据结构2.assets/image-20221012151204167.png)





##### 为什么一定需要中序遍历

![image-20221012151248013](数据结构2.assets/image-20221012151248013.png)







### 5.4.6 线索二叉树

![image-20221012153120565](数据结构2.assets/image-20221012153120565.png)



![image-20221012153336074](数据结构2.assets/image-20221012153336074.png)

#### 普通二叉树的问题

1. 如果希望遍历这棵树，必须从根节点开始进行遍历

2. 已知一个结点无法知道它的前驱，如果想要知道需要再进行一次遍历

   ![image-20221012153747311](数据结构2.assets/image-20221012153747311.png)





#### 中序线索二叉树

结点的空链域用来指向该结点的前驱和后继

线索的指向是按照中序遍历序列结果的前驱后继的顺序决定的

![image-20221012154043473](数据结构2.assets/image-20221012154043473.png)



线索二叉树的左右孩子指针有两个用于1.要么指向左右子树(左右孩子指针的本来用途) 2.要么指向前驱后继(如果该结点不是左右子树的延申用途)

![image-20221012154607879](数据结构2.assets/image-20221012154607879.png)



ltag rtag用来指示这个结点的左右指针是真的指向左右子树还是线索

![image-20221012154705904](数据结构2.assets/image-20221012154705904.png)



#### 先序线索二叉树

![image-20221012154822130](数据结构2.assets/image-20221012154822130.png)

![image-20221012154837485](数据结构2.assets/image-20221012154837485.png)



#### 后序线索二叉树

![image-20221012154935302](数据结构2.assets/image-20221012154935302.png)

![image-20221012154948584](数据结构2.assets/image-20221012154948584.png)



#### 总结

![image-20221012155016626](数据结构2.assets/image-20221012155016626.png)



![image-20221012155114542](数据结构2.assets/image-20221012155114542.png)



### 5.4.7 二叉树的线索化

#### 中序线索化

找前驱结点的土方法

- 对二叉树进行中序遍历，中序遍历过程中有两个指针m1,m2，m1记录当前访问的结点，m2记录当前访问的结点的前驱结点

- m1总是比m2先行一步

- 如果当前m1访问的结点不是要找的结点，那么让m2指向和m1指向同一个结点

  如果当前m1访问的结点就是要找的结点，那么保存当前m2的结点，就能得到目标结点的前驱结点

![image-20221012155942598](数据结构2.assets/image-20221012155942598.png)





二叉树中序线索化方法

- 对二叉树进行中序遍历，中序遍历过程中有两个指针m1,m2，m1记录当前访问的结点，m2记录当前访问的结点的前驱结点
- m1总是比m2先行一步
- 如果m1指向的结点左子树为空，那么建立前驱线索，由m1指向m2
- 如果m2不为空，且m2指向的结点右子树为空，那么建立后继线索，由m2指向m1
- m2 往后一步，m1往后一步，再次完成上述操作



![image-20221012161142848](数据结构2.assets/image-20221012161142848.png)



中序线索化完整代码

![image-20221012161220492](数据结构2.assets/image-20221012161220492.png)





#### 先序线索化

![image-20221012162125537](数据结构2.assets/image-20221012162125537.png)

![image-20221012162432541](数据结构2.assets/image-20221012162432541-16655630737341.png)

#### 后序线索化

![image-20221012162505086](数据结构2.assets/image-20221012162505086.png)

![image-20221012162548055](数据结构2.assets/image-20221012162548055.png)

#### 总结

![image-20221012162643726](数据结构2.assets/image-20221012162643726.png)

### 5.4.8 线索二叉树找前驱后继

![image-20221012162811122](数据结构2.assets/image-20221012162811122.png)



#### 中序线索二叉树

![image-20221012163246143](数据结构2.assets/image-20221012163246143.png)



![image-20221012163834330](数据结构2.assets/image-20221012163834330.png)







## 5.5 树的存储结构

![image-20221013160131223](数据结构2.assets/image-20221013160131223.png)

![image-20221013160208610](数据结构2.assets/image-20221013160208610.png)



### 双亲表示法(顺序结构)

![image-20221013160343606](数据结构2.assets/image-20221013160343606.png)



- 新增结点的方法：在数组中添加这个元素，和该元素的双亲结点的索引，添加过程无需按照逻辑上的次序存储

  ![image-20221013160619933](数据结构2.assets/image-20221013160619933.png)

  ![image-20221013160635284](数据结构2.assets/image-20221013160635284.png)

- 删除叶子结点的方法

  1.把相应位置数组的数据域置空，双亲位置域置成-1，表示这里已经空了，然后把结点数-1(不要用)

  2.把数组尾部元素移上去，填充这个空了的地方

  如果要删除的不是叶子结点怎么办，那就是删除了以该结点为根的子树，就是要查询

  

  

  

  

- 查询(查找)结点

  已知一个结点要查询其双亲结点很简单，看双亲位置域即可。

  要查找孩子结点，必须对数组从头到尾进行遍历，判断当前访问的结点的双亲位置域是否指向本结点

  ![image-20221013162018304](数据结构2.assets/image-20221013162018304.png)





### 孩子表示法(顺序+链式存储)

![image-20221013162202989](数据结构2.assets/image-20221013162202989.png)

![image-20221013162238278](数据结构2.assets/image-20221013162238278.png)





### 孩子兄弟表示法(纯链式存储)

树的结点有两个指针域，一个用来指向其第一个孩子，另一个指向其亲兄弟(注：不指向堂兄弟，必须是同一个父母)

![image-20221013162525177](数据结构2.assets/image-20221013162525177.png)



![image-20221013162836474](数据结构2.assets/image-20221013162836474.png)





### 森林和二叉树的转化

本质：孩子兄弟表示法存储森林

![image-20221013162959448](数据结构2.assets/image-20221013162959448.png)





![image-20221013163133493](数据结构2.assets/image-20221013163133493.png)



### 总结

![image-20221013163214423](数据结构2.assets/image-20221013163214423.png)



## 5.6 树和森林的遍历

![image-20221013163442855](数据结构2.assets/image-20221013163442855.png)

树是一种递归定义的数据结构



### 树的遍历

#### 先根遍历

![image-20221013170108558](数据结构2.assets/image-20221013170108558.png)



#### 后根遍历

![image-20221013170303094](数据结构2.assets/image-20221013170303094.png)



#### 层次遍历

树的广度优先遍历

![image-20221013170451950](数据结构2.assets/image-20221013170451950.png)





### 森林的遍历

#### 森林先序遍历

森林的先序遍历就是对其内部的各个树的依次先序遍历

![image-20221013170742011](数据结构2.assets/image-20221013170742011.png)

![image-20221013170825350](数据结构2.assets/image-20221013170825350.png)

#### 森林中序遍历

森林中序遍历相当于 对森林中的**各个子树**执行后根遍历(后序遍历)

![image-20221013170857822](数据结构2.assets/image-20221013170857822.png)

![image-20221013171000702](数据结构2.assets/image-20221013171000702.png)



#### 总结

![image-20221013171103554](数据结构2.assets/image-20221013171103554.png)









## 5.7 堆

### 堆的概念和存储表示

![image-20221018222700842](数据结构2.assets/image-20221018222700842.png)

![image-20221018222547460](数据结构2.assets/image-20221018222547460.png)

堆的定义

![image-20221018222744751](数据结构2.assets/image-20221018222744751.png)

堆一定是**完全二叉树**，采用顺序存储结构

![image-20221018222808898](数据结构2.assets/image-20221018222808898.png)

![image-20221018222821470](数据结构2.assets/image-20221018222821470.png)

![image-20221018223103614](数据结构2.assets/image-20221018223103614.png)

### 建堆运算

![image-20221018223143023](数据结构2.assets/image-20221018223143023.png)



![image-20221018223219572](数据结构2.assets/image-20221018223219572.png)

![image-20221018223229058](数据结构2.assets/image-20221018223229058.png)

例子：

从 46 开始，因为 46 是

![image-20221018223245749](数据结构2.assets/image-20221018223245749.png)

![image-20221018223253457](数据结构2.assets/image-20221018223253457.png)

![image-20221018223303466](数据结构2.assets/image-20221018223303466.png)

![image-20221018224046412](数据结构2.assets/image-20221018224046412.png)

![image-20221018224153242](数据结构2.assets/image-20221018224153242.png)

![image-20221018224205087](数据结构2.assets/image-20221018224205087.png)

![image-20221018224218976](数据结构2.assets/image-20221018224218976.png)

![image-20221018224229315](数据结构2.assets/image-20221018224229315.png)

![image-20221018224354694](数据结构2.assets/image-20221018224354694.png)

![image-20221018224415111](数据结构2.assets/image-20221018224415111.png)

### 优先权队列

![image-20221018224535971](数据结构2.assets/image-20221018224535971.png)

![image-20221018224545419](数据结构2.assets/image-20221018224545419.png)

![image-20221018224555893](数据结构2.assets/image-20221018224555893.png)

![image-20221018224605852](数据结构2.assets/image-20221018224605852.png)

![image-20221018224612898](数据结构2.assets/image-20221018224612898.png)

![image-20221018224629599](数据结构2.assets/image-20221018224629599.png)

![image-20221018224647248](数据结构2.assets/image-20221018224647248.png)

![image-20221018224656129](数据结构2.assets/image-20221018224656129.png)

![image-20221018224703217](数据结构2.assets/image-20221018224703217.png)

![image-20221018224713360](数据结构2.assets/image-20221018224713360.png)

![image-20221018224735613](数据结构2.assets/image-20221018224735613.png)

![image-20221018224749052](数据结构2.assets/image-20221018224749052-16661044773251.png)

![image-20221018224759689](数据结构2.assets/image-20221018224759689-16661044999172.png)

![image-20221018224822663](数据结构2.assets/image-20221018224822663.png)

![image-20221018224841026](数据结构2.assets/image-20221018224841026.png)









## 二叉排序树

![image-20221013171224234](数据结构2.assets/image-20221013171224234.png)

![image-20221013171252811](数据结构2.assets/image-20221013171252811.png)

对二叉排序树进行中序遍历，可以得到递增的有序序列

### 查找

![image-20221013171532606](数据结构2.assets/image-20221013171532606.png)



![image-20221013171619969](数据结构2.assets/image-20221013171619969.png)

循环的代码空间复杂度 是 O(1)

递归的代码空间复杂度是 O(n)

'

### 插入

每一次结点都是叶子结点

![](数据结构2.assets/image-20221013171931520.png)

按照给定序列构造二叉排序树

![image-20221013172206112](数据结构2.assets/image-20221013172206112.png)

![image-20221013172147223](数据结构2.assets/image-20221013172147223.png)

序列内部元素相同，但是这些元素顺序不同，构造出来的二叉排序树可能是不同的。

### 删除

#### 删除叶子结点

叶子结点可以直接删除

![image-20221013172439232](数据结构2.assets/image-20221013172439232.png)

#### 删除的结点只有左子树或者只有右子树

删除的结点的子树往上接

![image-20221013172520538](数据结构2.assets/image-20221013172520538.png)



#### 删除的结点有左右子树

要删除的结点为z，那么就让z的直接前驱或者直接后继代替z的位置，然后从二叉排序树中删除这个直接前驱或直接后继

如果其直接前驱或直接后继也是有左右子树，那么递归，也是让直接前驱(后继)的前驱(后继)代替，并且删除

![image-20221013173603751](数据结构2.assets/image-20221013173603751.png)



![image-20221013173933196](数据结构2.assets/image-20221013173933196.png)



### 查找效率

![image-20221013174236724](数据结构2.assets/image-20221013174236724.png)



如果一棵树高为h，那么找到最下层的结点需要对比h次(第几层就对比几次)

最好情况：n个结点的二叉树最小高度为 (log<sub>2</sub>n)向下取整 + 1   平均查找长度 = O(log<sub>2</sub>n) 

最坏情况：每个结点只有一个分支，树高h = 结点数n。平均查找长度 O(n)





![image-20221013174731707](数据结构2.assets/image-20221013174731707.png)

![image-20221013174907118](数据结构2.assets/image-20221013174907118.png)





### 总结

![image-20221013174929049](数据结构2.assets/image-20221013174929049.png)





## 平衡二叉树

![image-20221013175041918](数据结构2.assets/image-20221013175041918.png)

### 定义

![image-20221013175315050](数据结构2.assets/image-20221013175315050.png)

### 插入后为了再次平衡的调整

![image-20221013175352292](数据结构2.assets/image-20221013175352292.png)

不平衡的结点即，平衡因子不为+1 -1 0 的结点

![image-20221013175405537](数据结构2.assets/image-20221013175405537.png)

![image-20221013175432048](数据结构2.assets/image-20221013175432048.png)

只需要调整最小不平衡子树，其他的祖先结点也会恢复平衡



### 调整最小不平衡子树

![image-20221013175521359](数据结构2.assets/image-20221013175521359.png)

平衡二叉树表示为下图，我们设置A为最小不平衡子树的根结点

![image-20221013175903180](数据结构2.assets/image-20221013175903180.png)

只要A结点的右子树高度是 H，那么 B结点的左右子树高度一定也是 H，因为我们设置A为最小不平衡子树的根结点

调整目标

1. 恢复平衡

2. 保持二叉排序树特性

   ![image-20221013180249788](数据结构2.assets/image-20221013180249788.png)









#### LL

![image-20221013180133260](数据结构2.assets/image-20221013180133260.png)

解决方案

![image-20221013180221479](数据结构2.assets/image-20221013180221479.png)

![image-20221013180407455](数据结构2.assets/image-20221013180407455.png)



代码思路

![image-20221013180811459](数据结构2.assets/image-20221013180811459.png)



#### RR

![image-20221013180447911](数据结构2.assets/image-20221013180447911.png)

解决方案

![image-20221013180647540](数据结构2.assets/image-20221013180647540.png)

![image-20221013180631196](数据结构2.assets/image-20221013180631196.png)

代码思路

![image-20221013180901904](数据结构2.assets/image-20221013180901904.png)





#### LR

![image-20221013181027029](数据结构2.assets/image-20221013181027029.png)

c要旋转两次

![image-20221013181246741](数据结构2.assets/image-20221013181246741.png)

#### RL

![image-20221013181410562](数据结构2.assets/image-20221013181410562.png)

![image-20221013181442635](数据结构2.assets/image-20221013181442635-16656560836532.png)

#### 总结

![image-20221013181525079](数据结构2.assets/image-20221013181525079.png)



### 为什么只需要调整最小不平衡子树

![image-20221013181736405](数据结构2.assets/image-20221013181736405.png)

### 练习

1

![image-20221013181758084](数据结构2.assets/image-20221013181758084.png)

![image-20221013181815602](数据结构2.assets/image-20221013181815602.png)

2

![image-20221013181830899](数据结构2.assets/image-20221013181830899.png)



![image-20221013181856506](数据结构2.assets/image-20221013181856506.png)

![image-20221013181909596](数据结构2.assets/image-20221013181909596.png)

### 时间复杂度

![image-20221013182045267](数据结构2.assets/image-20221013182045267.png)

![image-20221013182059712](数据结构2.assets/image-20221013182059712.png)



![image-20221013182113346](数据结构2.assets/image-20221013182113346.png)



### 总结

![image-20221013182146036](数据结构2.assets/image-20221013182146036.png)





## 哈夫曼树(最优二叉树)

### 带权路径长度

![image-20221013153548228](数据结构2.assets/image-20221013153548228.png)

![image-20221013153646149](数据结构2.assets/image-20221013153646149.png)



### 哈夫曼树的定义

![image-20221013153755726](数据结构2.assets/image-20221013153755726.png)

![image-20221013153808354](数据结构2.assets/image-20221013153808354.png)





### 哈夫曼树的构造

![image-20221013154018435](数据结构2.assets/image-20221013154018435.png)

![image-20221013154210080](数据结构2.assets/image-20221013154210080.png)

哈夫曼树性质

![image-20221013154352026](数据结构2.assets/image-20221013154352026.png)

哈夫曼树不唯一，但是只要是通过这种方法构造出来的哈夫曼树WPL必然相同

### 哈夫曼编码

![image-20221013154914588](数据结构2.assets/image-20221013154914588-16656473560891.png)

固定长度编码：每个字符用相等长度的二进制位表示

如果要传递的字符只有 ABCD 那么可以用长度为2的二进制表示，用ascii码表示需要8位太麻烦了

可以把 ABCD作为4个结点构造成一颗树。左路径就是0，右路径就是1



![image-20221013155341035](数据结构2.assets/image-20221013155341035.png)

可变长度编码：允许对不同的字符用不等长的二进制位表示

选c的题为80，我们希望用更少的字符表示



前缀编码：若没有一个编码是另一个编码的前缀，则称这样的编码为前缀编码





![image-20221013155711814](数据结构2.assets/image-20221013155711814.png)

哈夫曼编码

- 字符集中的字符作为叶子结点
- 字符出现的频度(出现的多少)作为权值

![image-20221013155805151](数据结构2.assets/image-20221013155805151.png)



英文字母频次：在社会广大文章中，统计出哪些英文字母用的最多

![image-20221013155856376](数据结构2.assets/image-20221013155856376.png)



### 总结

![image-20221013155919363](数据结构2.assets/image-20221013155919363.png)



## B树

### M叉搜索树

#### M叉搜索树递归定义

m叉搜索树的m表示的是一个结点最多可以有多少子树

m叉的m是取决于**整个树中子树最多的结点的子树的数量是多少**

![image-20221106082327632](数据结构2.assets/image-20221106082327632.png)

![image-20221106082345058](数据结构2.assets/image-20221106082345058.png)

空树是失败结点，失败结点不是叶子结点



![image-20221106082453780](数据结构2.assets/image-20221106082453780.png)



#### M叉搜索树的作用(内搜索外搜索)

![image-20221106082523188](数据结构2.assets/image-20221106082523188.png)

为什么内存不用二叉搜索树

![image-20221106082604703](数据结构2.assets/image-20221106082604703.png)



举例

63个结点的二叉搜索树

![image-20221106082641714](数据结构2.assets/image-20221106082641714.png)

这原本是一颗二叉树

我们用多叉树代替二叉树，在一个结点中存放多个元素而非一个元素

可将7个结点放在一起组成一个元素，就形成了一个页

变成一个高度为2的八叉树

![image-20221106082807148](数据结构2.assets/image-20221106082807148.png)

#### M叉搜索树性质

![image-20221106082919887](数据结构2.assets/image-20221106082919887.png)

先算出最多结点，再一个结点最多能放多少个元素*最多结点

![image-20221106082956789](数据结构2.assets/image-20221106082956789.png)

### B树定义

#### B树的定义



![image-20221106083202787](数据结构2.assets/image-20221106083202787.png)

m/2 这个符号表示向上取整

B树是一颗M叉搜索树，并且满足更特殊的性质



![image-20221106083254963](数据结构2.assets/image-20221106083254963.png)

#### B树判定

![image-20221106083522847](数据结构2.assets/image-20221106083522847.png)

例子

![image-20221106083746432](数据结构2.assets/image-20221106083746432.png)

这是3阶B树也可能是4阶B树







#### B树性质

![image-20221106083957178](数据结构2.assets/image-20221106083957178.png)



![image-20221106084012684](数据结构2.assets/image-20221106084012684.png)

![image-20221106084151328](数据结构2.assets/image-20221106084151328.png)



![image-20221106084216137](数据结构2.assets/image-20221106084216137.png)

![image-20221106084619426](数据结构2.assets/image-20221106084619426.png)



#### B树的搜索

![image-20221106084913302](数据结构2.assets/image-20221106084913302.png)

![image-20221106085005691](数据结构2.assets/image-20221106085005691.png)



![image-20221106085013710](数据结构2.assets/image-20221106085013710.png)



![image-20221106085153401](数据结构2.assets/image-20221106085153401.png)

#### B树中插入操作

![image-20221106085359027](数据结构2.assets/image-20221106085359027.png)



在4阶B树中插入新元素59

![image-20221106085511922](数据结构2.assets/image-20221106085511922.png)

![image-20221106090321311](数据结构2.assets/image-20221106090321311.png)

溢出：因为结点的子树个数大于了m叉树的m

![image-20221106090720085](数据结构2.assets/image-20221106090720085.png)

<img src="数据结构2.assets/image-20221106090709720.png" alt="image-20221106090709720" style="zoom:50%;" />



<img src="数据结构2.assets/image-20221106090737679.png" alt="image-20221106090737679" style="zoom:67%;" />

插入运算结束



##### 插入操作总结

![image-20221106090916774](数据结构2.assets/image-20221106090916774.png)

![image-20221106090930696](数据结构2.assets/image-20221106090930696.png)



#### B树中删除操作

![image-20221106091233201](数据结构2.assets/image-20221106091233201.png)

![image-20221106091950114](数据结构2.assets/image-20221106091950114.png)

![image-20221106092058112](数据结构2.assets/image-20221106092058112.png)

![image-20221106092305024](数据结构2.assets/image-20221106092305024.png)



处理下溢出

![image-20221106092513302](数据结构2.assets/image-20221106092513302.png)

![image-20221106092643127](数据结构2.assets/image-20221106092643127.png)



![image-20221106092707316](数据结构2.assets/image-20221106092707316.png)

![image-20221106092719628](数据结构2.assets/image-20221106092719628.png)

又创造了其他下溢出





![image-20221106092859286](数据结构2.assets/image-20221106092859286.png)



<img src="数据结构2.assets/image-20221106092916017.png" alt="image-20221106092916017" style="zoom:67%;" />

先并

![image-20221106092944183](数据结构2.assets/image-20221106092944183.png)

再借

![image-20221106093011266](数据结构2.assets/image-20221106093011266.png)





##### 删除操作总结

![image-20221106093057639](数据结构2.assets/image-20221106093057639.png)

![image-20221106093147344](数据结构2.assets/image-20221106093147344.png)



![image-20221106093202027](数据结构2.assets/image-20221106093202027.png)











# 图

## 图的定义

![image-20220904164436042](数据结构2.assets/image-20220904164436042.png)

注：

1. G：graph  图  V：Vertex  顶点  E：Edge 边
2. V一定不能为空，但是E，即边可以为空
3. 图中顶点的个数称为图的**阶**



### 图逻辑的应用

![image-20220904164724660](数据结构2.assets/image-20220904164724660.png)

![image-20220904164805204](数据结构2.assets/image-20220904164805204.png)



### 有向图和无向图

![image-20220904164952963](数据结构2.assets/image-20220904164952963.png)

无向图： A到B 就是 B到A   有向图：B到A 不等于 A到B



### 简单图和多重图

![image-20220904165318107](数据结构2.assets/image-20220904165318107.png)

数据结构**不讨论多重图**。



### 有向图无向图的度

![image-20220904165823259](数据结构2.assets/image-20220904165823259.png)



### 顶点——顶点关系的描述

![image-20220904170629907](数据结构2.assets/image-20220904170629907.png)

### 连通图和强连通图

![image-20220904174859459](数据结构2.assets/image-20220904174859459.png)

连通图是针对 无向图 说的。

强连通图是针对 有向图 说的。

![image-20220904175612801](数据结构2.assets/image-20220904175612801.png)



![image-20220904175641184](数据结构2.assets/image-20220904175641184.png)

![image-20220904175717892](数据结构2.assets/image-20220904175717892.png)

### 子图

![image-20220904180146405](数据结构2.assets/image-20220904180146405.png)

子图：具有原图中的结点和原图中的边，并且还要能构成图

生成子图：具有原图中所有结点的子图



### 连通分量和强连通分量

连通分量：无向图中的极大连通子图称为连通分量。

连通分量一定是针对无向图而言的。



极大连通子图：子图必须**连通**，并且**包含尽可能多的顶点和边**

![image-20220904181258852](数据结构2.assets/image-20220904181258852.png)





强连通分量：有向图中的极大强连通子图称为强连通分量。

强连通分量一定是针对有向图而言的



极大强连通子图：子图必须强连通，并且尽可能包含多的边

![image-20220904181540818](数据结构2.assets/image-20220904181540818.png)



### 生成树

生成树是针对无向图的

极小连通子图：边尽可能小，但要保持连通。





![image-20220904182302770](数据结构2.assets/image-20220904182302770.png)



### 生成森林

![image-20220904190240096](数据结构2.assets/image-20220904190240096.png)

### 边的权、带权图、网

![image-20220904184933309](数据结构2.assets/image-20220904184933309.png)

### 特殊形态的图

![image-20220904185639821](数据结构2.assets/image-20220904185639821.png)

![image-20220904185735503](数据结构2.assets/image-20220904185735503.png)



树是特殊形态的图

![image-20220904190000493](数据结构2.assets/image-20220904190000493.png)

树是连通图，有向树不是连通图。



### 总结



![image-20221118122735910](数据结构2.assets/image-20221118122735910.png)

## 图的存储—邻接矩阵表示法

![image-20221118122847580](数据结构2.assets/image-20221118122847580.png)

无向图的邻接矩阵一定是关于主对角线对称的。无向图一条边对应一个1，有向图一条边对应两个1



![image-20221118123033098](数据结构2.assets/image-20221118123033098.png)

一维数组用来存放结点。

二维数组用来表示两结点中一个边



邻接矩阵表示法如何求顶点的度，入度，出度

对于无向图

![image-20221118123232876](数据结构2.assets/image-20221118123232876.png)

对于有向图

![image-20221118123313365](数据结构2.assets/image-20221118123313365.png)

![image-20221118123324416](数据结构2.assets/image-20221118123324416.png)



邻接矩阵表示法存储网

![image-20221118123412058](数据结构2.assets/image-20221118123412058.png)

邻接矩阵中的值不再是 0 和 1 ，而是权重值，如果两个结点之间没有边，那么就存储无穷，权值无限大



有时候 自回路权重会表示成0

![image-20221118123611809](数据结构2.assets/image-20221118123611809.png)



邻接矩阵法性能分析

![image-20221118123725089](数据结构2.assets/image-20221118123725089.png)



![image-20221118123735115](数据结构2.assets/image-20221118123735115.png)



邻接矩阵法的性质，离散数学

![image-20221118123916552](数据结构2.assets/image-20221118123916552.png)

离散数学公式：![image-20221118123937747](数据结构2.assets/image-20221118123937747.png)





总结

![image-20221118124250946](数据结构2.assets/image-20221118124250946.png)



## 图的存储—**邻接表法**

邻接表法：顺序表+链表，类似于拉链法



链表存储的边的起点都是**指向了该链表的数组元素存储的顶点**，终点不一定



![image-20221118124400915](数据结构2.assets/image-20221118124400915.png)

顶点使用数组来存储，边(连接顶点和顶点的)，使用链表存储

![image-20221118124554303](数据结构2.assets/image-20221118124554303.png)

ArcNode * first 指针用来指向链表的首结点

![image-20221118124628377](数据结构2.assets/image-20221118124628377.png)

adjvex 数据存储的是这个边的另一个顶点在数组中的索引

![image-20221118124601922](数据结构2.assets/image-20221118124601922.png)

vexnum是顶点的数量，arcnum边的数量。

AdjList vertices 是用来存储顶点的一维数组



存储有向图

![image-20221118124826598](数据结构2.assets/image-20221118124826598.png)



图邻接表表示方法不唯一，链表前后顺序可以不同

![image-20221118125317349](数据结构2.assets/image-20221118125317349.png)



求顶点入度，出度

无向图根据邻接表找度很方便，

有向图根据邻接表找出度很方便，找入度不方便，需要遍历整个邻接表



总结

![image-20221118125437356](数据结构2.assets/image-20221118125437356.png)

## 图的存储—**十字链表、邻接多重表**

十字链表存储有向图

临界多重表存储无向图



十字链表存储有向图解决邻接表存储有向图求顶点入度不方便的问题

![image-20221118125651204](数据结构2.assets/image-20221118125651204.png)

十字链表性能分析

![image-20221118130347343](数据结构2.assets/image-20221118130347343.png)



**邻接多重表**

![image-20221118155211018](数据结构2.assets/image-20221118155211018.png)

![image-20221118155608681](数据结构2.assets/image-20221118155608681.png)

![image-20221118155621424](数据结构2.assets/image-20221118155621424.png)

## 图的基本操作和邻接矩阵、邻接表怎么实现

![image-20221118155958964](数据结构2.assets/image-20221118155958964.png)



### 判断图中是否存在某条边

![image-20221118160027846](数据结构2.assets/image-20221118160027846.png)

邻接矩阵，找到 x，y 位置处那个值是否为1   时间复杂度 O(1)

邻接表，检查边的起始顶点的链表(遍历链表)有没有另一个顶点  时间复杂度 O(1)~O(n)

![image-20221118160331761](数据结构2.assets/image-20221118160331761.png)



### 列出图G中的与结点x邻接的边

![image-20221118160405354](数据结构2.assets/image-20221118160405354.png)

邻接矩阵，只需要进行遍历顶点所在的那一行， 时间复杂度 O(n)

邻接表，遍历顶点x所指向的链表，用时多少取决于链表长度 ，时间复杂度 O(1) ~O(n)

![image-20221118160755906](数据结构2.assets/image-20221118160755906.png)



### 插入新顶点

![image-20221118161011750](数据结构2.assets/image-20221118161011750.png)

### 删除顶点

![image-20221118161235976](数据结构2.assets/image-20221118161235976.png)

邻接矩阵，把那一行那一列的元素全部都变成，可以再在顶点数据类型加上bool型来判断是不是空结点

邻接表，删除数组的那个对应的顶点元素，并且删除该链表

![image-20221118161320745](数据结构2.assets/image-20221118161320745.png)



### 添加边

![image-20221118161418053](数据结构2.assets/image-20221118161418053.png)

邻接矩阵对应位置 0 变成 1

邻接表使用头插法添加元素，

两个方法时间复杂度都是O(1)

### 删除边

![image-20221118161614194](数据结构2.assets/image-20221118161614194.png)

### 找到顶点x第一个邻接点

FirstNeighbor

![image-20221118161642883](数据结构2.assets/image-20221118161642883.png)

邻接矩阵，找到矩阵相应那一行，从左往右找第一个1



![image-20221118161850803](数据结构2.assets/image-20221118161850803.png)

邻接矩阵，出边找行，入边找列

邻接表，找入边很难，找出边就是遍历链表

### 找第一个临界点之后的临界点

NextNeighbor

![image-20221118162114511](数据结构2.assets/image-20221118162114511.png)

### 获取权值设置权值

![image-20221118162143765](数据结构2.assets/image-20221118162143765.png)

## **图的广度优先遍历**

### 树和图遍历对比

![image-20221118162624144](数据结构2.assets/image-20221118162624144.png)

广度优先遍历是先获取一个结点后，再遍历其邻接的结点

### 图的广度优先遍历代码实现

![image-20221118162801019](数据结构2.assets/image-20221118162801019.png)

**访问标记数组**标记某个顶点有没有被访问过

![image-20221118162817291](数据结构2.assets/image-20221118162817291.png)



数组遍历初始位置从1开始

![image-20221118162909199](数据结构2.assets/image-20221118162909199.png)

先访问元素2，2入队列，然后让与其邻接的顶点入队

<img src="数据结构2.assets/image-20221118163356946.png" alt="image-20221118163356946" style="zoom:50%;" />

<img src="数据结构2.assets/image-20221118163455955.png" alt="image-20221118163455955" style="zoom: 50%;" />

2号出队，让与1号结点和5号结点相邻的并且没有被访问过的入队



![image-20221118163554697](数据结构2.assets/image-20221118163554697.png)

1 号 和 6号 出队。

访问5号结点的时候，会把和5号结点邻接(但是没有访问过)的结点加入到队列中，但是没有，然后5号出队

访问3号结点的时候，会把和5号结点邻接(但是没有访问过)的结点加入到队列中，即4号结点，然后3号出队

访问7号结点的时候，会把和5号结点邻接(但是没有访问过)的结点加入到队列中，即8号结点，然后7号出队



![image-20221118163906433](数据结构2.assets/image-20221118163906433.png)

4 和 8 的与其邻接的都是被访问过的，所以不会再操作了



一个结点与多个结点邻接，那么下一层遍历的顺序是**按照从小到大的顺序进行遍历**

![image-20221118164143980](数据结构2.assets/image-20221118164143980.png)

但是如果邻接表存储结构不一样，从一个点出发，找到别的顶点的顺序可能不同(链表元素的位置不同)。

但是邻接矩阵存储遍历肯定是每一次从小到大排列

![image-20221118164358962](数据结构2.assets/image-20221118164358962.png)

对于无向图，调用BFS函数的次数=连通分量数目



性能分析

![image-20221118164902074](数据结构2.assets/image-20221118164902074.png)

### 广度优先生成树

广度优先生成树根据遍历的顺序得来的

![image-20221118165347116](数据结构2.assets/image-20221118165347116.png)

广度优先生成树顺序不唯一

### 广度优先生成森林

![image-20221118165508795](数据结构2.assets/image-20221118165508795.png)

### 有向图BFS

![image-20221118165544112](数据结构2.assets/image-20221118165544112.png)



### 总结

![image-20221118165607164](数据结构2.assets/image-20221118165607164.png)

##  **图的深度优先遍历**

类似于树的先根遍历

![image-20221118172701204](数据结构2.assets/image-20221118172701204.png)





### 图的深度优先遍历代码实现

![image-20221118172716259](数据结构2.assets/image-20221118172716259.png)



先访问 2号结点

<img src="数据结构2.assets/image-20221118172819593.png" alt="image-20221118172819593" style="zoom:50%;" />

<img src="数据结构2.assets/image-20221118172908050.png" alt="image-20221118172908050" style="zoom:50%;" />

<img src="数据结构2.assets/image-20221118172925157.png" alt="image-20221118172925157" style="zoom:50%;" />

5号执行完没了，以及最深了，那么触底反弹，到1号结点，1号结点周围也都被访问过，也执行完了，那么回到执行2号结点

接着执行2号结点的 for 循环

<img src="数据结构2.assets/image-20221118173052835.png" alt="image-20221118173052835" style="zoom:50%;" />

访问6号结点

<img src="数据结构2.assets/image-20221118173135178.png" alt="image-20221118173135178" style="zoom:50%;" />

再往深处，3号结点

<img src="数据结构2.assets/image-20221118173157550.png" alt="image-20221118173157550" style="zoom:50%;" />

再往深处，4号结点

<img src="数据结构2.assets/image-20221118173235051.png" alt="image-20221118173235051" style="zoom:50%;" />

再往深处，7号，7号完了8号

<img src="数据结构2.assets/image-20221118173331132.png" alt="image-20221118173331132" style="zoom:50%;" />

8号执行完了周围都没有没被访问的了，同样对于  7 号 4号 3号 6号 2号周围也都没有没被访问的了

![image-20221118173421653](数据结构2.assets/image-20221118173421653.png)



考虑非连通图，完整代码

![image-20221118173500767](数据结构2.assets/image-20221118173500767.png)



算法性能分析

![image-20221118173612246](数据结构2.assets/image-20221118173612246.png)

![image-20221118173659995](数据结构2.assets/image-20221118173659995.png)



![image-20221118173905605](数据结构2.assets/image-20221118173905605.png)

![image-20221118174003400](数据结构2.assets/image-20221118174003400.png)

### 深度优先生成树

![image-20221118174032377](数据结构2.assets/image-20221118174032377.png)

![image-20221118174045427](数据结构2.assets/image-20221118174045427.png)

### 深度优先生成树

![image-20221118174108360](数据结构2.assets/image-20221118174108360.png)

![image-20221118174122000](数据结构2.assets/image-20221118174122000.png)

### 图的遍历与图的连通性

![image-20221118174151601](数据结构2.assets/image-20221118174151601.png)

![image-20221118174217472](数据结构2.assets/image-20221118174217472.png)

### 总结

![image-20221118174232115](数据结构2.assets/image-20221118174232115.png)



## 拓扑排序

### aov网、拓扑排序、拓扑序列

![image-20221123085242857](数据结构2.assets/image-20221123085242857.png)

![image-20221123085316622](数据结构2.assets/image-20221123085316622.png)

![image-20221123085344088](数据结构2.assets/image-20221123085344088.png)





![image-20221123085538415](数据结构2.assets/image-20221123085538415.png)

拓扑序列不唯一

### 给定 aov网如何拓扑排序

<img src="数据结构2.assets/image-20221123085747838.png" alt="image-20221123085747838" style="zoom:67%;" />

<img src="数据结构2.assets/image-20221123085837594.png" alt="image-20221123085837594" style="zoom:67%;" />



<img src="数据结构2.assets/image-20221123085909470.png" alt="image-20221123085909470" style="zoom:67%;" />

可以用堆栈或者队列保存新产生的入度为0的顶点

举例

<img src="数据结构2.assets/image-20221123090026420.png" alt="image-20221123090026420" style="zoom:67%;" />

<img src="数据结构2.assets/image-20221123090045986.png" alt="image-20221123090045986" style="zoom: 50%;" />

<img src="数据结构2.assets/image-20221123090100004.png" alt="image-20221123090100004" style="zoom:50%;" />

<img src="数据结构2.assets/image-20221123090123372.png" alt="image-20221123090123372" style="zoom: 50%;" />

<img src="数据结构2.assets/image-20221123090204263.png" alt="image-20221123090204263" style="zoom:50%;" />

得到拓扑序列

<img src="数据结构2.assets/image-20221123090219086.png" alt="image-20221123090219086" style="zoom:50%;" />

![image-20221123090257382](数据结构2.assets/image-20221123090257382.png)



### 实现拓扑排序算法的程序

<img src="数据结构2.assets/image-20221123090404779.png" alt="image-20221123090404779" style="zoom:67%;" />

<img src="数据结构2.assets/image-20221123090509946.png" alt="image-20221123090509946" style="zoom:67%;" />



算法具体实现



计算各顶点入度

<img src="数据结构2.assets/image-20221123090603853.png" alt="image-20221123090603853" style="zoom:67%;" />



![image-20221123090651706](数据结构2.assets/image-20221123090651706.png)

![image-20221123090744822](数据结构2.assets/image-20221123090744822.png)

<img src="数据结构2.assets/image-20221123090824442.png" alt="image-20221123090824442" style="zoom:50%;" />

## 关键路径

### AOE网

<img src="数据结构2.assets/image-20221123091138554.png" alt="image-20221123091138554" style="zoom: 50%;" />

![image-20221123091241934](数据结构2.assets/image-20221123091241934.png)

### 关键路径，关键活动

![image-20221123091331525](数据结构2.assets/image-20221123091331525.png)

AOE网上各个活动是可以并行的。

### 事件相关的两个基本概念

![image-20221123091516215](数据结构2.assets/image-20221123091516215.png)

### 活动相关的两个基本概念

![image-20221123091606755](数据结构2.assets/image-20221123091606755.png)

### 关键路径的求解过程

![image-20221123091913790](数据结构2.assets/image-20221123091913790.png)

![image-20221123091932387](数据结构2.assets/image-20221123091932387.png)

<img src="数据结构2.assets/image-20221123091952574.png" alt="image-20221123091952574" style="zoom:50%;" />

<img src="数据结构2.assets/image-20221123092239398.png" alt="image-20221123092239398" style="zoom:50%;" />

每个事件(结点)的最早发生时间是，从源点(入度为0的点)，到该事件(结点)的各路径中，所用最长的时间(权重最大的那种走法)。

![image-20221123092644966](数据结构2.assets/image-20221123092644966.png)

![image-20221123092715530](数据结构2.assets/image-20221123092715530.png)

![image-20221123092948982](数据结构2.assets/image-20221123092948982.png)

![image-20221123092956711](数据结构2.assets/image-20221123092956711.png)

### 关键路径算法的实现

![image-20221123123721079](数据结构2.assets/image-20221123123721079.png)

![image-20221123123812182](数据结构2.assets/image-20221123123812182.png)

## 最小代价生成树

### 概念

![image-20221123123937188](数据结构2.assets/image-20221123123937188.png)

最小代价生成树：带权的连通图，寻找一棵生成树(极小连通子图)，使得各条边上的权值之和最小





![image-20221123124055159](数据结构2.assets/image-20221123124055159.png)

![image-20221123124105723](数据结构2.assets/image-20221123124105723.png)

G4代价是该图所有生成树中最小的

![image-20221123124205246](数据结构2.assets/image-20221123124205246.png)

### 普里姆算法

![image-20221123124449063](数据结构2.assets/image-20221123124449063.png)

’

案例

![image-20221123124656543](数据结构2.assets/image-20221123124656543.png)

无向图，T的入边指的是**一个顶点属于T，另一个顶点不属于T的边。**(不能两个顶点都属于和两个顶点都不属于)

- 初始状态仅包含0，T的入边有 1-0 2-0 3-0 其中 2-0权重最小

  ![image-20221123124900323](数据结构2.assets/image-20221123124900323.png)

  将边 2-0 和 不属于 T的顶点 顶点2 加入

   T现在有 两个顶点 顶点 0 和 2

-  T现在有 两个 顶点 0 和 2    T的入边有 1-0  3-0 1-2 4-2 3-2 5-2   其中 5-2 权值最小

  ![image-20221123125414134](数据结构2.assets/image-20221123125414134.png)

  边 和 顶点 5 加入

  T 现在有 三个顶点 顶点 0 2 5

- T 现在有 三个顶点 顶点 0 2 5 T的入边有  0-3 2-3 5-3 0-1 2-1 2-4 5-4 其中 5-3 权值最小

  ![image-20221123125742319](数据结构2.assets/image-20221123125742319.png)

  边和另一头顶点 3加入

  T现在有 四个顶点 顶点 0  2  3  5

- T现在有 四个顶点 顶点 0  2  3  5   T的入边有 1-0 1-2 4-2 4-5    1-2 权值最小

  ![image-20221123125912242](数据结构2.assets/image-20221123125912242.png)

  边和另一头结点 1 加入

  T现在有 五个顶点，顶点 0 1 2 3 5

- T现在有 五个顶点，顶点 0 1 2 3 5   T的 入边有 4-1 4-2 4-5   4-1权值最小

  ![image-20221123130021205](数据结构2.assets/image-20221123130021205.png)

  顶点全部包含，结束

![image-20221123130044336](数据结构2.assets/image-20221123130044336.png)

#### 存储结构

![image-20221123130201852](数据结构2.assets/image-20221123130201852.png)

#### 过程分析

![image-20221123130212131](数据结构2.assets/image-20221123130212131.png)

![image-20221123130233237](数据结构2.assets/image-20221123130233237.png)

![image-20221123130442539](数据结构2.assets/image-20221123130442539.png)

![image-20221123130547090](数据结构2.assets/image-20221123130547090.png)

以上表中第二列作为讲解，

- 因为 生成树中距离顶点1最近的结点是生成树中的顶点0，因此 nearest[1] = 0
- 因为 生成树中距离顶点1最近的结点(即顶点0)和顶点1的边的权是2，所以 lowcost[1] = 2

​                                 

![image-20221123131001084](数据结构2.assets/image-20221123131001084.png)

![image-20221123131019485](数据结构2.assets/image-20221123131019485.png)

![image-20221123131030667](数据结构2.assets/image-20221123131030667.png)

![image-20221123131120394](数据结构2.assets/image-20221123131120394.png)

![image-20221123131148402](数据结构2.assets/image-20221123131148402.png)

![image-20221123131200111](数据结构2.assets/image-20221123131200111.png)

![image-20221123131209487](数据结构2.assets/image-20221123131209487.png)

‘![image-20221123131225688](数据结构2.assets/image-20221123131225688.png)

#### 核心步骤

![image-20221123131309363](数据结构2.assets/image-20221123131309363.png)

#### 程序实现

![image-20221123131355178](数据结构2.assets/image-20221123131355178.png)

### 克鲁斯卡尔算法

![image-20221123133026406](数据结构2.assets/image-20221123133026406.png)



![image-20221123133148934](数据结构2.assets/image-20221123133148934.png)



- 把 G中 0-2 删除，加入 T ，未形成回路

  ![image-20221123133222433](数据结构2.assets/image-20221123133222433.png)

- 把 G 中 3-5删除，加入 T，未形成回路

  ![image-20221123133317414](数据结构2.assets/image-20221123133317414.png)

- 把 G 中 1-4删除，加入 T，未形成回路

  ![image-20221123133350413](数据结构2.assets/image-20221123133350413.png)

- 把 G中 2-5删除，加入 T ，未形成回路

  ![image-20221123133428205](数据结构2.assets/image-20221123133428205.png)

- ![image-20221123133448737](数据结构2.assets/image-20221123133448737.png)

  不能 0-3   会形成回路，选择 1-2

  ![image-20221123133532581](数据结构2.assets/image-20221123133532581.png)

  结束(已经有 n-1 条边)



#### 存储结构

![image-20221123133607392](数据结构2.assets/image-20221123133607392.png)

#### 核心步骤

![image-20221123133742999](数据结构2.assets/image-20221123133742999.png)

#### 程序实现

![image-20221123133902873](数据结构2.assets/image-20221123133902873.png)

![image-20221123133935330](数据结构2.assets/image-20221123133935330.png)



## 单源最短路径

![image-20221123134053387](数据结构2.assets/image-20221123134053387.png)



单源最短路径问的是什么问题

![image-20221123134113715](数据结构2.assets/image-20221123134113715.png)

![image-20221123134133036](数据结构2.assets/image-20221123134133036.png)

![image-20221123134216294](数据结构2.assets/image-20221123134216294.png)

### 迪杰斯特拉算法

![image-20221123134341427](数据结构2.assets/image-20221123134341427.png)

![image-20221123134459601](数据结构2.assets/image-20221123134459601.png)



1. 每次在加入新结点到S中的时候都需要检查是否从 v0 开始(并且只允许通过 S集合 中的顶点),是否有到达其他结点更短的路径。
2. 每一轮检查完后都标注出到S集合以外的各个结点的路径长度(已经在S集合以内的就固定了，不会再改变了)。
3. 再从v0到各个结点的路径长度中选择最短的路径的另一头的终点顶点加入到 S集合中
4. 重复以上步骤



#### 存储结构

![image-20221123134942412](数据结构2.assets/image-20221123134942412.png)



#### 算法实际举例

![image-20221123142003249](数据结构2.assets/image-20221123142003249.png)

![image-20221123142234587](数据结构2.assets/image-20221123142234587.png)

![image-20221123142340133](数据结构2.assets/image-20221123142340133.png)

![image-20221123142441464](数据结构2.assets/image-20221123142441464.png)



![image-20221123142528537](数据结构2.assets/image-20221123142528537.png)



![image-20221123142655126](数据结构2.assets/image-20221123142655126.png)

![image-20221123142758175](数据结构2.assets/image-20221123142758175.png)

![image-20221123142823563](数据结构2.assets/image-20221123142823563.png)

![image-20221123142854874](数据结构2.assets/image-20221123142854874.png)

![image-20221123142937883](数据结构2.assets/image-20221123142937883.png)



#### 程序实现

![image-20221123143104958](数据结构2.assets/image-20221123143104958.png)

![image-20221123143159600](数据结构2.assets/image-20221123143159600.png)
