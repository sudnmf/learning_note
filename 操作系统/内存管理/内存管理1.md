# 一、内存的基础知识

![image-20220914170955328](内存管理1.assets/image-20220914170955328.png)







![image-20220914160227528](内存管理1.assets/image-20220914160227528.png)

内存中有多个程序的数据，这些程序是并发执行的，这就需要我们对内存进行区分，哪些部分是该程序的，哪些部分是另一个程序的。

区分的方法：给内存的存储单元编址



![image-20220914160613438](内存管理1.assets/image-20220914160613438.png)

1. 内存中有一个个小房间，每个小房间就是一个"存储单元"

2. 如果计算机"按字节编址"则每个存储单元大小为1字节，即1B，即8个2进制位，每个地址对应一个字节

3. 如果字长为16位的计算机"按字编制"，则每个存储单元大小为1个字；每个字的大小为 16 个二进制位，每个地址对应两个字节

4. 内存地址从0开始，每个地址对应一个存储单元，存储单元是存储数据的最小单位，存储单元可能是1字节，也有可能是2字节



![image-20220914161248551](内存管理1.assets/image-20220914161248551.png)



## 指令的工作原理

进程中分为  程序段：存放指令   数据段：存放程序中的变量  



CPU取指执行，CPU依次读取程序段指令，然后就能从指令中知道它要执行什么操作，然后就去做，如此往复。

![image-20220914161929648](内存管理1.assets/image-20220914161929648.png)





思考，如果进程不是从地址#0开始存放的，会影响指令的正常执行吗。

为了简化理解，我们默认操作系统给进程分配的是一片连续的存储空间





可执行文件.exe 也被称作装入模块，然后.exe 文件就能放在内存中运行了。

但是这个可执行文件的指令的地址参数都是逻辑地址(相对地址)，这个地址是相对这个进程起始地址的地址



假设装入模块装入内存中进程的起始地址正好是0地址。这个程序的逻辑地址和物理地址恰好就对应上了

![image-20220914162836639](内存管理1.assets/image-20220914162836639.png)

假设这个进程是从地址为100的地方开始的。这个程序的逻辑地址和物理地址就对应不上

![image-20220914162923987](内存管理1.assets/image-20220914162923987.png)

可能会导致往其他内存区域写入数据

![image-20220914163031844](内存管理1.assets/image-20220914163031844.png)



## 装入的三种方式

绝对装入

**![image-20220914163527830](内存管理1.assets/image-20220914163527830.png)**

绝对装入灵活性非常差，程序必须装入内存中唯一确定的位置





静态重定位

![image-20220914163759461](内存管理1.assets/image-20220914163759461.png)

作业一旦进入内存后，在运行期间就不能再移动，也不能再申请内存空间



动态重定位

![image-20220914165842195](内存管理1.assets/image-20220914165842195.png)



编译、链接后的装入模块的地址都是 假设这段程序起始地址为0写成的。这是相对地址。

相对地址 + 重定位寄存器的值 = 绝对地址



## 从写程序到程序运行

![image-20220914170308757](内存管理1.assets/image-20220914170308757.png)

## 链接的三种方式

静态链接

![image-20220914170438317](内存管理1.assets/image-20220914170438317.png)

把目标模块和库函数连接成一个完整的可执行文件(装入模块)直接确认了完整的逻辑地址。





装入时动态链接

![image-20220914170834597](内存管理1.assets/image-20220914170834597.png)

![image-20220914170843579](内存管理1.assets/image-20220914170843579.png)



运行时动态链接

![image-20220914170903107](内存管理1.assets/image-20220914170903107.png)

![image-20220914170939408](内存管理1.assets/image-20220914170939408.png)



# 二、内存管理的概念

![image-20220914172538410](内存管理1.assets/image-20220914172538410.png)

## 内存空间的扩展



操作系统作为对系统资源的管理者，也要对内存进行管理

1.内存空间的分配与回收

![image-20220914171246243](内存管理1.assets/image-20220914171246243.png)

2.操作系统需要提供某种技术从逻辑上对内存空间进行扩充

![image-20220914171454142](内存管理1.assets/image-20220914171454142.png)

3.地址转换

![image-20220914171537352](内存管理1.assets/image-20220914171537352.png)

![image-20220914171700543](内存管理1.assets/image-20220914171700543.png)

## 内存保护

内存中分为 操作系统使用的内存区域   和  普通应用程序使用的内存区域



进程只能访问本进程的数据，不能访问其他进程的内存，更不能访问操作系统占用的内存。





假设进程1，逻辑地址空间为 0~179，物理地址空间为 100~279

内存保护采取的方法

方法1

![image-20220914172147078](内存管理1.assets/image-20220914172147078.png)

方法2

![image-20220914172444083](内存管理1.assets/image-20220914172444083.png)

![image-20220914172520425](内存管理1.assets/image-20220914172520425.png)



# 三、覆盖与交换

![image-20220914175718109](内存管理1.assets/image-20220914175718109.png)

![image-20220914172727452](内存管理1.assets/image-20220914172727452.png)

## 覆盖技术

![image-20220914173037697](内存管理1.assets/image-20220914173037697.png)



![image-20220914173048855](内存管理1.assets/image-20220914173048855.png)







举例：

![image-20220914173416309](内存管理1.assets/image-20220914173416309.png)

A 调用 B 和 C , B 和 C 一定不是同时执行的，所以可以先A后B

D 和 E 和 F是同一层级的，所以也可以按照先后顺序，使用同一片内存区域



覆盖结构几乎不用了



## 交换技术



![image-20220914174938195](内存管理1.assets/image-20220914174938195.png)

**进程的PCB需要常驻内存**，存储这个进程被换入了外存的哪个位置，到时候可以再把这个进程调出来运行

![image-20220914175107612](内存管理1.assets/image-20220914175107612.png)





![image-20220914175329530](内存管理1.assets/image-20220914175329530.png)



![image-20220914175611623](内存管理1.assets/image-20220914175611623.png)



# 四、连续分配管理方式

![image-20220915103846265](内存管理1.assets/image-20220915103846265.png)

![image-20220915085851329](内存管理1.assets/image-20220915085851329.png)

连续分配：系统为用户进程分配的一定是连续的存储空间

非连续分配：系统为用户进程分配的是离散的存储空间





## 单一连续分配

同一时间用户区只能存在一个用户进程

![image-20220915093639836](内存管理1.assets/image-20220915093639836.png)

## 固定分区分配

![image-20220915093945578](内存管理1.assets/image-20220915093945578.png)

![image-20220915094253331](内存管理1.assets/image-20220915094253331.png)

## 动态分区分配

可变分区分配

![image-20220915094459327](内存管理1.assets/image-20220915094459327.png)



问题：

![image-20220915094531800](内存管理1.assets/image-20220915094531800.png)



系统要使用什么数据结构来记录内存的状态

- 空闲分区表
- 空闲分区链



![image-20220915094743850](内存管理1.assets/image-20220915094743850.png)

空闲分区表

![image-20220915094802308](内存管理1.assets/image-20220915094802308.png)

空闲分区表：每个空闲分区对应一个表项。表项中包含分区号、分区大小、分区起始地址等信息。







空闲分区链

![image-20220915094810348](内存管理1.assets/image-20220915094810348.png)

空闲分区链：每个分区的起始部分和末尾部分分别设置前向指针和后向指针。起始部分处还可记录分区大小等信息





当许多内存满足即将要加入到内存中的进程，选择哪块内存

![image-20220915095313587](内存管理1.assets/image-20220915095313587.png)

使用动态分区分配算法





分区的分配与回收

以动态分区表为例子

![image-20220915095524098](内存管理1.assets/image-20220915095524098.png)

只需要修改分区表中的分区大小和起始地址





![image-20220915095559618](内存管理1.assets/image-20220915095559618-16632069606961.png)

如果空闲分区恰好没了，就要把对应的表相删除





空闲分区回收，如果恰好有相邻的空闲分区，合二为一

![image-20220915095747127](内存管理1.assets/image-20220915095747127.png)





如果被回收的前面和后面都有空闲分区，那么也要进行合并，就是3个进行合并

![image-20220915095915367](内存管理1.assets/image-20220915095915367.png)

![image-20220915095926141](内存管理1.assets/image-20220915095926141.png)





如果回收区的前后都没有空闲分区，需要增加表项

![image-20220915103212103](内存管理1.assets/image-20220915103212103.png)



### 紧凑技术

![image-20220915103804196](内存管理1.assets/image-20220915103804196.png)

内部碎片：分配给某进程的内存区域中，如果有些部分没有用上。

外部碎片：内存中某些空闲分区由于太小而难以利用。

外部碎片的问题可以用紧凑技术解决







下图为例

假如，进程1原来在内存中，由于需要等待事件的完成处于阻塞态，被交换出内存，把进程2交换进入内存占据原来进程1的位置，但是进程2太小了没法完全占满，就产生了外部碎片。

![image-20220915103639570](内存管理1.assets/image-20220915103639570.png)

假如进程1好了，又想回到内存，由于每个外部碎片空间都太小了进程1无法进入，就可以通过紧凑的技术把进程贴在一起，从而能得到更大的内存碎片，就可以让进程1放入内存中。

把系统中的进程挪动位置

![image-20220915103707976](内存管理1.assets/image-20220915103707976.png)



![image-20220915103722480](内存管理1.assets/image-20220915103722480.png)

# 五、动态分区分配算法

![image-20220915121647244](内存管理1.assets/image-20220915121647244.png)

![image-20220915121521879](内存管理1.assets/image-20220915121521879.png)

# 六、基本分页存储管理的概念

![image-20220915133245942](内存管理1.assets/image-20220915133245942.png)

![image-20220915121916360](内存管理1.assets/image-20220915121916360.png)

页框是内存的分块，页和页面是进程的逻辑地址空间的分块



## 页表

![image-20220915125940385](内存管理1.assets/image-20220915125940385.png)

内存块就是页框

通过页表知道逻辑地址中的第几页存储在地址空间中的哪里





每个页表项占多少个字节

**块号需要占多少存储空间需要进行计算**

![image-20220915130315382](内存管理1.assets/image-20220915130315382.png)

**页号不需要占用存储空间**

![image-20220915130349733](内存管理1.assets/image-20220915130349733.png)

知道起始地址和偏移值就可以得到每个页的地址

![image-20220915130410783](内存管理1.assets/image-20220915130410783.png)

![image-20220915130514890](内存管理1.assets/image-20220915130514890.png)

![image-20220915130528788](内存管理1.assets/image-20220915130528788.png)





## 如何实现地址的转换

进程在内存连续存放的时候，操作系统借助重定位寄存器，将逻辑地址变为物理地址

![image-20220915130713249](内存管理1.assets/image-20220915130713249.png)



离散存放的特点：虽然页面是离散存放的，但是页面内部是连续存放的。

![image-20220915130910330](内存管理1.assets/image-20220915130910330.png)

![image-20220915130932871](内存管理1.assets/image-20220915130932871.png)

### 如何确定一个逻辑地址确定的页号，页内偏移量

页号 = 逻辑地址/页面长度(取除法的整数部分)   

页内偏移量 = 逻辑地址%页面长度 (取除法的余数部分)

在计算机内部，地址是用二进制表示的，如果页面大小刚好是 2 的整数幂，则计算机硬件可以很快速的把逻辑地址拆分成(页号,页内偏移量)

结论：如果每个页面大小为 2<sup>k</sup>B，用二进制数表示逻辑地址，则末尾 k 位即为页内偏移量，其余部分就是页号。

**除2的n次方数 就是右移位运算，所以低位 k 得到 2的k次方 就是 页面的长度，其余的高位就是 页号**

假设 计算机地址 用32个2进制位表示逻辑地址，页面为 4KB，2 的 12次方



![image-20220915132105606](内存管理1.assets/image-20220915132105606.png)





![image-20220915132428484](内存管理1.assets/image-20220915132428484.png)

结论：如果页面大小刚好是2的整数幂，则只需把页表中记录的物理块号拼接上页内偏移量就能得到对应的物理地址。



逻辑地址对应的物理地址 = 页面在内存中存放的起始地址(页表中记录的内存块号(即：n号内存块的n)写成2进制形式) + 页内偏移量(逻辑地址的最后12位)

![image-20220915133116423](内存管理1.assets/image-20220915133116423.png)



![image-20220915133206401](内存管理1.assets/image-20220915133206401.png)

![image-20220915133218998](内存管理1.assets/image-20220915133218998.png)

# 七、基本地址变换机构

![image-20220916174128827](内存管理1.assets/image-20220916174128827.png)



![image-20220916184257187](内存管理1.assets/image-20220916184257187.png)

注意：页面的大小是 2 的 整数幂

![image-20220916184416715](内存管理1.assets/image-20220916184416715.png)







1. 从 PCB 中加载页表始址和页表长度(页表长度就表示有多少个页表)
2. 根据逻辑地址计算出页号、页内偏移量 (上节课讲过，页内偏移量就是低字节部分，页号就是高字节部分)。
3. 看看这个页号是否超过了页表的数量(即页表长度)，如果超过了说明这个页号越界了，异常中断
4. 如果没有越界，就把 页表始址 和 页号 P 搭配起来找 页号P所对应的内存块号
5. 用内存块号和页内偏移量得到物理地址(物理地址 = 内存中页面的地址 + 页面偏移量)
6. 访问目标内存单元

![image-20220916184819854](内存管理1.assets/image-20220916184819854.png)

![image-20220916190300032](内存管理1.assets/image-20220916190300032.png)

页表项长度是已知的，是一个页表项的大小，页表是数组，页表项就是其中一个元素。页表项长度就是步长。每个页表项长度是相同的。

页表长度 = 表项数 * 表项长度

![image-20220916190639221](内存管理1.assets/image-20220916190639221.png)



## 页表项大小进一步探讨

![image-20220916191105561](内存管理1.assets/image-20220916191105561.png)

![image-20220916191151404](内存管理1.assets/image-20220916191151404.png)

进程页通常是装在连续的内存块中的，为了保证是用同一种方法  (页表始址 + 页表项长度*页号)取得内存块号

![image-20220916191502656](内存管理1.assets/image-20220916191502656.png)

![image-20220916191707734](内存管理1.assets/image-20220916191707734.png)





# 八、具有快表的地址变换机构

![image-20220916191835053](内存管理1.assets/image-20220916191835053.png)

![image-20220916194346781](内存管理1.assets/image-20220916194346781.png)

## 什么是快表

![image-20220916192223179](内存管理1.assets/image-20220916192223179.png)



快表的查询速度比慢表快很多

![image-20220916194419228](内存管理1.assets/image-20220916194419228.png)

## 引入快表后地址变换过程

![image-20220916192836138](内存管理1.assets/image-20220916192836138.png)



![image-20220916193147780](内存管理1.assets/image-20220916193147780.png)











一次访存：已经从快表中的得到内存块了，所以不需要访问慢表，直接去取数据。

二次访存：由于快表没有命中，所以需要访问内存中的慢表，这是第一次访问，取得内存块信息，第二次访问去对应地址取数据



快表中只存储了慢表中的一部分数据

![image-20220916193441950](内存管理1.assets/image-20220916193441950.png)



什么叫快表和慢表同时查找

![image-20220916194044041](内存管理1.assets/image-20220916194044041.png)





## 局部性原理

![image-20220916194323266](内存管理1.assets/image-20220916194323266.png)
